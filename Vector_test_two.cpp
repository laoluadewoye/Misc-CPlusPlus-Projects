//Project #6 - Improved byte key encryption with vector. Key and input can now be various lengths, and autogenerated if wanted.

#include <iostream>
#include <vector>

using namespace std;

int main () {
    
    //establishing beginning
    vector<int> hinput;
    vector<int> randkey;
    int shifter = 0; int shiftertwo = 0;
    int length, lengthtwo;
    vector<int> output;
    int pushb;
    string choose; 
    
    cout << "Welcome to the new and improved X-OR key! How long do you want your input to be?\n";
    cin >> length;
    cout << "Do you wish to have your input autogenerated (pick 'yes' or 'no')?\n";
    cin >> choose;
    
    
    //the human/PRNG input
    if (choose == "yes") {
        
        while (shifter != length) {
            hinput.push_back(rand() % 2);
            shifter++;
        }
    }
    else if (choose == "no") {
        while (shifter != length) {
            cout << "Type in '1' or '0'.\n";
            cin >> pushb;
            hinput.push_back(pushb);
            shifter++;
        }
    }
    shifter = 0;
    cout << "Input: ";
    while (shifter != length) {
        cout << hinput[shifter] << " ";
        shifter++;
    }
    

    //The key production (make it custom)
    cout << "\n" << "How long do you want your key? (if you want the key to be the same lenght as input type same number)\n";
    cin >> lengthtwo;
    
    shifter = 0;
    cout << "Encrypting Key: ";
    while (shifter != lengthtwo) {
        randkey.push_back(rand() % 2);
        cout << randkey[shifter] << " ";
        shifter++;
    }
    
    
    //actual encryption. Supposedly hardest part
    cout << "\n" << "Ciphertext: ";
    shifter = 0;
    while (shifter != length) {
        if (hinput[shifter] == randkey[shiftertwo]) {
            output.push_back(0);
        }
        else if (hinput[shifter] != randkey[shiftertwo]) {
            output.push_back(1);
        }
        shifter++; shiftertwo++;
        if (shiftertwo == lengthtwo) {
            shiftertwo = 0;
        }
        cout << output[shifter] << " ";
    }
    
    
    return 0;
}


